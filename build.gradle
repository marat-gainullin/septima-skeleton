import com.septima.entities.SqlEntities
import com.zaxxer.hikari.HikariConfig
import com.zaxxer.hikari.HikariDataSource

import javax.naming.Context
import javax.naming.InitialContext

System.setProperty(Context.INITIAL_CONTEXT_FACTORY, Jndi.class.getName())

buildscript {
    repositories {
        jcenter()
        maven {
            url "https://plugins.gradle.org/m2/"
        }
        mavenLocal()
    }
    dependencies {
        classpath 'com.h2database:h2:1.4.193',
                'com.septimajs:septima-js-model:0.0.1',
                'com.septimajs:septima-js-generator:0.0.1',
                'com.zaxxer:HikariCP:2.7.6',
                'com.moowork.gulp:com.moowork.gulp.gradle.plugin:1.2.0'
    }
}

apply plugin: 'war'
apply plugin: 'com.moowork.gulp'

sourceSets {
    main {
        java {
            srcDirs = [
                    'src/server/main/java',
                    "${buildDir}/generated-src/entities",
                    "${buildDir}/generated-src/models"
            ]
        }
        resources {
            srcDirs = ['src/server/main/resources']
        }
    }
    test {
        java {
            srcDirs = ['src/server/test/java']
        }
        resources {
            srcDirs = ['src/server/test/resources']
        }
    }
}

configurations {
    compile.transitive = false
    tomcat
    containerLibs
    h2
}

def tomcatVersion = '9.0.2'

repositories {
    jcenter()
    mavenCentral()
}

dependencies {
    compileOnly 'javax.servlet:javax.servlet-api:3.1.0',
            'javax.websocket:javax.websocket-api:1.1',
            'javax.mail:mail:1.4.7'
    compile 'com.septimajs:septima-js-model:0.0.1',
            'com.septimajs:septima-js-data:0.0.1',
            'com.septimajs:septima-js-application:0.0.1',
            'com.fasterxml.jackson.core:jackson-core:2.9.2',
            'com.fasterxml.jackson.core:jackson-databind:2.9.2'
    runtime 'com.septimajs:septima-js-sql-driver-h2:0.0.1'
    tomcat "org.apache.tomcat:tomcat-catalina:$tomcatVersion",
            "org.apache.tomcat:tomcat-jasper:$tomcatVersion",
            "org.apache.tomcat:tomcat-dbcp:$tomcatVersion",
            "org.apache.tomcat:tomcat-websocket:$tomcatVersion",
            "org.apache.tomcat:tomcat-jaspic-api:$tomcatVersion"
    containerLibs 'com.h2database:h2:1.4.193'
    // , ... another jdbc driver for another database
    h2 'com.h2database:h2:1.4.193'
}

def tomcatDir = "${buildDir}/tomcat"
def tomcatBinDir = "${tomcatDir}/bin"
def sharedLibDir = "${tomcatDir}/lib"
def h2Dir = "${System.getProperty('user.home')}/.septima/h2"

task buildTomcatBin(type: Copy) {
    configurations.tomcat.each {
        from file(it)
    }
    into tomcatBinDir
}

task buildSharedLibs(type: Copy) {
    configurations.containerLibs.each {
        from file(it)
    }
    into sharedLibDir
}

task buildTomcat() {
}

buildTomcat.dependsOn buildTomcatBin,
        buildSharedLibs

task cleanTomcat(type: Delete) {
    delete tomcatDir
}

clean.dependsOn cleanTomcat

def asProps = { fileName ->
    def loaded = new Properties()
    def inputFile = file(fileName)
    if (inputFile.exists()) {
        inputFile.withInputStream {
            loaded.load(it)
        }
    }
    return loaded
}

def check = { map, prop, value ->
    if (!map.containsKey(prop)) {
        map[prop] = value
    }
}

def props = asProps('project.properties')
check props, 'application.context', 'change-me-context'

def privateProps = asProps('private.properties')
check privateProps, 'tomcat.http.port', 8085
check privateProps, 'tomcat.log.level', 'INFO'
check privateProps, 'tomcat.debug.port', 5007
check privateProps, 'application.security', false

def dataSources = [] as Set
props.each {
    def matcher = (it.key =~ "data-source\\.([a-zA-Z_/\\-]+)\\..*")
    if (matcher.matches()) {
        def dsName = matcher.group(1)
        def dbUrl = props["data-source.${dsName}.dburl"]
        if (!dbUrl)
            throw new GradleException("'data-source.${dsName}.dburl' project property not found or is not defined")
        def jdbcDriverClass = props["data-source.${dsName}.jdbcDriverClass"]
        if (!jdbcDriverClass)
            throw new GradleException("'data-source.${dsName}.jdbcDriverClass' project property not found or is not defined")
        def dbUser = props["data-source.${dsName}.dbuser"]
        if (!dbUser)
            throw new GradleException("'data-source.${dsName}.dbuser' project property not found or is not defined")
        def dbPassword = props["data-source.${dsName}.dbpassword"]
        def dbSchema = props["data-source.${dsName}.dbschema"]
        def maxConnections = props["data-source.${dsName}.max.connections"]
        def maxStatements = props["data-source.${dsName}.max.statements"]
        dataSources << [
                name          : dsName,
                url           : dbUrl,
                driverClass   : jdbcDriverClass,
                user          : dbUser,
                password      : dbPassword,
                schema        : dbSchema,
                maxConnections: maxConnections,
                maxStatements : maxStatements
        ]
    }
}

task warExplode(type: Copy) {
    with war
    into "$tomcatDir/web-apps/${props['application.context']}"
}

def webAppUrl = privateProps['browser.url'] ? privateProps['browser.url'] : "http://localhost:${privateProps['tomcat.http.port']}/${props['application.context']}"

task configureTomcat(type: Copy) {
    def confSourceDir = 'src/server/tomcat'
    def confDestDir = "${tomcatDir}/conf"
    outputs.upToDateWhen { false }
    from confSourceDir
    into confDestDir
    include 'default-web.xml'
    rename 'default-web.xml', 'web.xml'
    doLast {
        def conf = file("${confSourceDir}/server.xml").withInputStream {
            return new XmlParser().parse(it)
        }
        def connectors = conf.Service.Connector
        if (connectors.isEmpty())
            throw new GradleException("'Connector' tag not found in server.xml or it is not on path: 'Server/Service/Connector'")
        def connectorNode = connectors[0]
        connectorNode.attributes()['port'] = privateProps['tomcat.http.port']

        def contexts = conf.Service.Engine.Host.Context
        if (contexts.isEmpty())
            throw new GradleException("'Context' tag not found in server.xml or it is not on path: 'Server/Service/Engine/Host/Context'")
        def contextNode = contexts[0]
        contextNode.attributes()['path'] = "/${props['application.context']}"
        contextNode.attributes()['docBase'] = "${tomcatDir}/web-apps/${props['application.context']}"
        def generalDsName = props['application.data-source']
        def enableSecurityRealm = privateProps['application.security'] == 'true'
        def realmAdded = false
        dataSources.each {
            def ds = it

            if (enableSecurityRealm && generalDsName && generalDsName == ds.name) {
                def realmNode = contextNode.appendNode(new groovy.xml.QName("Realm"), [
                        'className'      : "org.apache.catalina.realm.DataSourceRealm",
                        'dataSourceName' : ds.name,
                        'localDataSource': "true",
                        'roleNameCol'    : "GROUP_NAME",
                        'userCredCol'    : "USR_PASSWD",
                        'userNameCol'    : "USR_NAME",
                        'userRoleTable'  : "APP_USERS_GROUPS",
                        'userTable'      : "APP_USERS"
                ])
                realmNode.appendNode(new groovy.xml.QName("CredentialHandler"), [
                        className: "org.apache.catalina.realm.MessageDigestCredentialHandler",
                        algorithm: "md5"
                ])
                realmAdded = true
            }
            def dsAttributes = [
                    name           : ds.name,
                    url            : ds.url,
                    username       : ds.user,
                    driverClassName: ds.driverClass,
                    type           : 'javax.sql.DataSource'
            ]
            if (ds.password != null)
                dsAttributes.password = ds.password

//            if(ds.schema != null)
//                dsAttributes.schema = ds.schema
//            if(ds.maxConnections != null)
//                dsAttributes.maxActive = ds.maxConnections
//            if(ds.maxStatements != null)
//                dsAttributes.maxStatements = ds.maxStatements

            contextNode.appendNode(new groovy.xml.QName('Resource'), dsAttributes)
        }
        if (enableSecurityRealm && !realmAdded) {
            throw new GradleException("Security realm can not be added because application data source is not found.")
        }
        file("${confDestDir}/server.xml").withOutputStream {
            groovy.xml.XmlUtil.serialize(conf, it)
        }
        def loggingProps = asProps("${confSourceDir}/logging.properties")
        loggingProps['org.apache.juli.FileHandler.level'] = privateProps['tomcat.log.level']
        loggingProps['java.util.logging.ConsoleHandler.level'] = privateProps['tomcat.log.level']
        file("${confDestDir}/logging.properties").withOutputStream {
            loggingProps.store(it, 'Tomcat logging configuration. Septima profile.')
        }
    }
}

task tomcatCommand(type: JavaExec) {
    workingDir tomcatDir
    classpath fileTree(tomcatBinDir)
    main 'org.apache.catalina.startup.Bootstrap'
    jvmArgs '-Xdebug',
            "-Xrunjdwp:server=y,transport=dt_socket,address=${privateProps['tomcat.debug.port']},suspend=n",
            "-Djava.util.logging.config.file=${file(tomcatDir)}/conf/logging.properties"
}

def launchTomcat = {
    def instance = new ProcessBuilder(tomcatCommand.commandLine)
            .directory(file(tomcatCommand.workingDir))
            .redirectErrorStream(true).start()
    def stdOut = new InputStreamReader(instance.getInputStream())
    try {
        def tomcatNextLine = stdOut.readLine()
        while (tomcatNextLine != null && !tomcatNextLine.contains('Server startup in')) {
            if (!tomcatNextLine.isEmpty())
                println(tomcatNextLine)
            tomcatNextLine = stdOut.readLine()
        }
        if (tomcatNextLine != null && !tomcatNextLine.isEmpty())
            println(tomcatNextLine)
        println()
        println 'Tomcat started.'
        println "Further logs you can find at: ${tomcatDir}/logs"
    } finally {
        stdOut.close()
    }
    return instance
}

def shutdownTomcat = { instance ->
    instance.destroy()
    instance.waitFor()
    println()
    println 'Tomcat shutted down'
}

task buildH2(type: Copy) {
    configurations.h2.each {
        from file(it)
    }
    into h2Dir
}

task h2Command(type: JavaExec) {
    classpath fileTree(h2Dir)
    main 'org.h2.tools.Server'
    args '-tcp'
}

def launchH2 = {
    def h2Server = new ProcessBuilder(h2Command.commandLine)
            .redirectErrorStream(true)
            .start()
    def h2StdOut = new InputStreamReader(h2Server.getInputStream())
    try {
        def h2NextLine = h2StdOut.readLine()
        while (!h2NextLine.contains('TCP server running at')) {
            if (!h2NextLine.isEmpty())
                println(h2NextLine)
            h2NextLine = h2StdOut.readLine()
        }
        if (!h2NextLine.isEmpty())
            println(h2NextLine)
        println("H2 server started")
        println()
    } finally {
        h2StdOut.close()
    }
    return h2Server
}

task fillH2(type: Copy) {
    from "${projectDir}"
    include 'base.sql'
    into "$buildDir/tmp/database/"
    rename 'base.sql', 'base.sql.applied'

    doFirst {
        def runScript = {
            org.h2.tools.RunScript.main(
                    '-url', props["data-source.${props['application.data-source']}.dburl"],
                    '-user', props["data-source.${props['application.data-source']}.dbuser"],
                    '-password', props["data-source.${props['application.data-source']}.dbpassword"],
                    '-script', "${projectDir}/base.sql"
            )
            println 'Application database filled'
        }
        try {
            runScript()
        } catch (org.h2.jdbc.JdbcSQLException ex) {
            if (ex.cause instanceof java.net.ConnectException) {
                println 'H2 is not running. Trying to start it ...'
                launchH2()
                runScript()
            } else {
                throw ex
            }
        }
    }
    doLast {
        delete generateEntities.outputs
        println 'Generated entities cleared'
    }
}
fillH2.dependsOn buildH2


task run() {
    doFirst {
        def tomcatServer = launchTomcat()
        println "Application is now served at ${webAppUrl}"
        println()
        println 'To terminate press enter ...'
        System.in.read()
        shutdownTomcat tomcatServer
        println()
        println 'See you next time :)'
    }
}
run.dependsOn buildTomcat,
        configureTomcat,
        warExplode,
        fillH2

task bindDataSources() {
    doFirst {
        def naming = new InitialContext()
        dataSources.forEach {
            HikariConfig config = new HikariConfig()
            config.jdbcUrl = it.url
            config.username = it.user
            config.driverClassName = it.driverClass
            if (it.password != null)
                config.password = it.password
            if (it.maxConnections != null)
                config.maximumPoolSize = it.maxConnections
            // ds.maxStatements
            //if (it.schema != null)
            //    config.schema = it.schema
            naming.bind it.name, new HikariDataSource(config)
        }
        println 'data sources bound'
    }
}
bindDataSources.dependsOn fillH2

def sqlEntitiesSource = new SqlEntities(file('src/server/main/resources/entities').toPath(), props['application.data-source'])

task generateEntities(type: GenerateEntities) {
    sqlEntities = sqlEntitiesSource
    sqlEntitiesDir = sqlEntitiesSource.getEntitiesRoot().toFile()
    generatedSourcesDir = file("${buildDir}/generated-src/entities")
    doLast {
        delete generateModels.outputs
        println 'Generated models cleared'
    }
}
generateEntities.dependsOn bindDataSources

task generateModels(type: GenerateModels) {
    sqlEntities = sqlEntitiesSource
    modelsDir = file('src/server/main/models')
    generatedSourcesDir = file("${buildDir}/generated-src/models")
}
generateModels.dependsOn generateEntities

compileJava.dependsOn generateModels

node {
    // Version of node to use.
    version = '9.4.0'

    npmVersion = '5.6.0'
    yarnVersion = '1.3.2'
    distBaseUrl = 'https://nodejs.org/dist'
    download = true

    // A directory for unpacking node
    workDir = file('src/client/downloads/nodejs')

    // A directory for NPM
    npmWorkDir = file('src/client/downloads/npm')

    // A directory for Yarn
    yarnWorkDir = file('src/client/downloads/yarn')

    // A directory where mode_modules is located
    nodeModulesDir = file('src/client')
}

gulp {
    // A directory where 'gulpfile.js' or 'gulpfile.babel.js' is located
    workDir = file("src/client")
    colors = true
}

gulp_clean.dependsOn 'installGulp', 'npmInstall'

task gulp_bundle_dev(type: GulpTask) {
    args = ['bundle', '--design', '--dev']
}

gulp_bundle_dev.dependsOn 'installGulp', 'npmInstall'
gulp_bundle_dev.inputs.file 'src/client/package.json'
gulp_bundle_dev.inputs.dir 'src/client/src'
gulp_bundle_dev.inputs.dir 'src/client/design'
gulp_bundle_dev.outputs.dir 'src/client/build/bundle'

gulp_bundle.dependsOn 'installGulp', 'npmInstall'
gulp_bundle.inputs.dir 'src/client/src'
gulp_bundle.outputs.dir 'src/client/build/bundle'

task gulp_design_pages(type: GulpTask) {
    doFirst {
        if (!project.hasProperty('view')) {
            throw new GradleException("Project property 'view' is required for design task")
        }
    }
    args = ['design-page', '--view', project.hasProperty('view') ? project['view'] : '-', '--dest', '../design/']
}

gulp_design_pages.dependsOn gulp_bundle_dev

task design() {
    doLast {
        java.awt.Desktop.desktop.browse new java.net.URL("$webAppUrl/design-${project['view'].replaceAll('/', '-')}.html").toURI()
    }
}

task designPages(type: Copy) {
    from 'src/client/build/design'
    into "$tomcatDir/web-apps/${props['application.context']}"
}
designPages.dependsOn gulp_design_pages

design.dependsOn warExplode, designPages

war {
    from 'src/client/build/bundle'
    webXml = file('src/server/web.xml')
}

warExplode.dependsOn gulp_bundle_dev
war.dependsOn gulp_bundle

clean.dependsOn gulp_clean